#!/usr/bin/perl

my $RCS_Id = '$Id: ebshell,v 1.3 2005/09/01 15:21:00 jv Exp $ ';

# Author          : Johan Vromans
# Created On      : Thu Jul  7 15:53:48 2005
# Last Modified By: Johan Vromans
# Last Modified On: Thu Sep  1 14:27:16 2005
# Update Count    : 163
# Status          : Unknown, Use with caution!

################ Common stuff ################

use strict;

# Package or program libraries, if appropriate.
# $LIBDIR = $ENV{'LIBDIR'} || '/usr/local/lib/sample';
# use lib qw($LIBDIR);
# require 'common.pl';

# Package name.
my $my_package = 'EekBoek';
# Program name and version.
my ($my_name, $my_version) = $RCS_Id =~ /: (.+).pl,v ([\d.]+)/;
# Tack '*' if it is not checked in into RCS.
$my_version .= '*' if length('$Locker:  $ ') > 12;

################ Command line parameters ################

use Getopt::Long 2.13;

# Command line options.
my $interactive = -t;
my $command;
my $echo;
my $dataset;
my $schema;			# initialise w/ schema
my $confirm = 0;
my $journal = 0;
my $verbose = 0;		# verbose processing

# Development options (not shown with -help).
my $debug = 0;			# debugging
my $trace = 0;			# trace (show process)
my $test = 0;			# test mode.

# Process command line options.
app_options();

# Post-processing.
$trace |= ($debug || $test);

################ Presets ################

my $TMPDIR = $ENV{TMPDIR} || $ENV{TEMP} || '/usr/tmp';

################ The Process ################

use base qw(EB::Shell);

my $app = $my_package;
my $userdir = glob("~/.".lc($app));
mkdir($userdir) unless -d $userdir;
$echo = "eb> " if $echo;

if ( $dataset ) {
    $ENV{EB_DB_NAME} = $dataset;
    $ENV{EB_DB} = "dbi:Pg:dbname=$dataset";
}

unless ( $ENV{EB_DB_NAME} ) {
    die("?Geen database opgegeven. Gebruik de environment variabele EB_DB_NAME om een database te selecteren, of geef een database naam mee op de command line met \"--data=...\".\n");
}

use EB::DB;
our $dbh = EB::DB->new(trace => $trace);

if ( $schema ) {
    require EB::Tools::Schema;
    $dbh->connectdb(undef, 1);
    EB::Tools::Schema->create($schema);
}

my $shell = EB::Shell->new
  ({ HISTFILE	  => $userdir."/history",
     command	  => $command,
     interactive  => $interactive,
     verbose	  => $verbose,
     trace	  => $trace,
     journal	  => $journal,
     echo	  => $echo,
     prompt	  => lc($app)." [$ENV{EB_DB_NAME}] ",
   });

$| = 1;

$shell->run;

################ Subroutines ################

sub app_options {
    my $help = 0;		# handled locally
    my $ident = 0;		# handled locally

    # Process options, if any.
    # Make sure defaults are set before returning!
    return unless @ARGV > 0;

    if ( !GetOptions(
		     'command'	=> sub {
			 $command = 1;
			 die("!FINISH\n");
		     },
		     'schema=s' => \$schema,
		     'echo!'	=> \$echo,
		     'ident'	=> \$ident,
		     'journal'	=> \$journal,
		     'verbose'	=> \$verbose,
		     'data=s'	=> \$dataset,
		     'trace'	=> \$trace,
		     'help|?'	=> \$help,
		     'debug'	=> \$debug,
		    ) or $help )
    {
	app_usage(2);
    }
    app_ident() if $ident;
}

sub app_ident {
    print STDERR ("This is $my_package [$my_name $my_version]\n");
}

sub app_usage {
    my ($exit) = @_;
    app_ident();
    print STDERR <<EndOfUsage;
Usage: $0 [options] [file ...]

    --command  -c       voer de rest van de opdrachtregel uit als command
    --echo  -e          toon ingelezen opdrachten
    --journal           print journaalregels na elke opdracht
    --data=DB           specificeer database
    --help		this message
    --ident		show identification
    --verbose		verbose information
EndOfUsage
    exit $exit if defined $exit && $exit != 0;
}
